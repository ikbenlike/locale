%{
#include <string>
#include <cstdint>
#include "util.hpp"
#include "locale.hpp"
#include "locale.bragi.hpp"
%}

%require "3.2"
%language "c++"

%define parse.trace

%define api.token.constructor
%define api.prefix {locale_parser}
%define api.value.type variant

%token <std::string> CONFIG
%token <std::string> CHARACTER_NAME
%token <uint8_t> CHARACTER_LITERAL
%token EOL
%token <std::string> STRING
%token <int16_t> NUMBER
%token SEMICOLON
%token BRACKET_OPEN
%token BRACKET_CLOSE
%token COMMA
%token <std::string> TEXT
%token T_LC_CTYPE
%token T_LC_COLLATE
%token T_LC_MESSAGES
%token T_LC_MONETARY
%token T_LC_NUMERIC
%token T_LC_TIME
%token T_LC_ADDRESS
%token T_LC_IDENTIFICATION
%token T_LC_MEASUREMENT
%token T_LC_NAME
%token T_LC_PAPER
%token T_LC_TELEPHONE
%token <std::string> FIELD_CTYPE_PAIRS
%token <std::string> FIELD_CTYPE_CHARS
%token <std::string> FIELD_COLLATE
%token <std::string> FIELD_MESSAGES
%token <std::string> FIELD_MONETARY_STRING
%token <std::string> FIELD_MONETARY_SINGLE_BYTE
%token <std::string> FIELD_MONETARY_BYTES
%token <std::string> FIELD_NUMERIC_STRING
%token <std::string> FIELD_NUMERIC_BYTES
%token <std::string> FIELD_TIME_STRING
%token <std::string> FIELD_TIME_MULTIPLE_STRINGS
%token <std::string> FIELD_ADDRESS
%token <std::string> FIELD_IDENTIFICATION
%token <std::string> FIELD_MEASUREMENT
%token <std::string> FIELD_NAME
%token <std::string> FIELD_PAPER
%token <std::string> FIELD_TELEPHONE
%token COPY
%token END
%token ESCAPE
%token ORDER_START
%token ORDER_END
%token FORWARD
%token BACKWARD
%token UNDEFINED
%token IGNORE
%token POSITION

%type <pair> field_ctype_single_pair_value
%type <std::vector<pair>> field_ctype_pairs_value
%type <std::string> character_literals character_value
%type <std::vector<int16_t>> field_bytes_value
%type <std::vector<std::string>> field_chars_value field_strings_value
%type <lc_ctype *> section_ctype
%type <lc_collate *> section_collate
%type <lc_time *> section_time
%type <lc_numeric *> section_numeric
%type <lc_messages *> section_messages
%type <lc_monetary *> section_monetary
%type <Locale *> sections

%code {
    namespace locale_parser {
        parser::symbol_type locale_parserlex();
    }
}

%%

file : locale_file YYEOF { YYACCEPT; } ;

locale_file
 :
 | prelude sections
 | sections
 ;

newlines
 : EOL
 | newlines EOL
 ;

prelude
 : configs ;

configs
 : CONFIG TEXT newlines { locale::set_config($1, $2); }
 | configs CONFIG TEXT newlines { locale::set_config($2, $3); }
 ;

section
 : section_ctype
 | section_collate
 | section_monetary
 | section_numeric
 | section_time
 | section_messages
 ;

sections
 : section
 | sections section
 ;

section_ctype
 : T_LC_CTYPE EOL COPY STRING EOL END T_LC_CTYPE newlines { $$ = new lc_ctype; }
 | T_LC_CTYPE EOL definitions_ctype END T_LC_CTYPE newlines
 ;

definitions_ctype
 : single_definition_ctype
 | definitions_ctype single_definition_ctype
 ;

single_definition_ctype
 : FIELD_CTYPE_PAIRS field_ctype_pairs_value newlines
 | FIELD_CTYPE_CHARS field_chars_value newlines
 ;

field_ctype_pairs_value
 : field_ctype_single_pair_value { $$ = std::vector<pair>{$1}; }
 | field_ctype_pairs_value SEMICOLON field_ctype_single_pair_value { $1.push_back($3); $$ = $1; }
 | field_ctype_pairs_value SEMICOLON ESCAPE EOL field_ctype_single_pair_value { $1.push_back($5); $$ = $1; }
 ;

field_ctype_single_pair_value
 : BRACKET_OPEN character_value COMMA character_value BRACKET_CLOSE
 {
    auto p = pair{};
    p.set_left($2);
    p.set_right($4);
    $$ = p;
 };

section_collate
 : T_LC_COLLATE EOL COPY STRING EOL END T_LC_COLLATE newlines
 | T_LC_COLLATE EOL collate_start definitions_collate ORDER_END EOL END T_LC_COLLATE newlines
 ;

collate_start
 : ORDER_START EOL
 | ORDER_START order_operands EOL
 ;

order_operands
 : order_operand
 | order_operands SEMICOLON order_operand
 ;

order_operand
 : FORWARD
 | BACKWARD
 | POSITION
 ;

definitions_collate
 : single_definition_collate
 | definitions_collate single_definition_collate
 ;

single_definition_collate
 : CHARACTER_NAME EOL
 | CHARACTER_NAME collate_char_specifiers EOL
 | UNDEFINED EOL
 ;

collate_char_specifiers
 : collate_char_specifier
 | collate_char_specifiers SEMICOLON collate_char_specifier
 ;

collate_char_specifier
 : CHARACTER_NAME
 | IGNORE
 | STRING
 ;

section_monetary
 : T_LC_MONETARY EOL COPY STRING EOL END T_LC_MONETARY newlines
 | T_LC_MONETARY EOL definitions_monetary END T_LC_MONETARY newlines
 ;

definitions_monetary
 : single_definition_monetary
 | definitions_monetary single_definition_monetary
 ;

single_definition_monetary
 : FIELD_MONETARY_STRING STRING EOL
 | FIELD_MONETARY_SINGLE_BYTE NUMBER EOL
 | FIELD_MONETARY_BYTES field_bytes_value EOL
 ;

section_numeric
 : T_LC_NUMERIC EOL COPY STRING EOL END T_LC_NUMERIC newlines
 | T_LC_NUMERIC EOL definitions_numeric END T_LC_NUMERIC newlines
 ;

field_chars_value
 : character_value { $$ = std::vector<std::string>{$1}; }
 | field_chars_value SEMICOLON character_value { $1.push_back($3);  }
 | field_chars_value SEMICOLON ESCAPE EOL character_value { $1.push_back($5); $$ = $1; }
 ;

definitions_numeric
 : single_definition_numeric
 | definitions_numeric single_definition_numeric
 ;

single_definition_numeric
 : FIELD_NUMERIC_STRING STRING EOL
 | FIELD_NUMERIC_BYTES field_bytes_value EOL
 ;

section_time
 : T_LC_TIME EOL COPY STRING EOL END T_LC_TIME newlines
 | T_LC_TIME EOL definitions_time END T_LC_TIME newlines
 ;

definitions_time
 : single_definition_time
 | definitions_time single_definition_time
 ;

single_definition_time
 : FIELD_TIME_STRING STRING EOL
 | FIELD_TIME_MULTIPLE_STRINGS field_strings_value EOL
 ;

section_messages
 : T_LC_MESSAGES EOL COPY STRING EOL END T_LC_MESSAGES newlines
 | T_LC_MESSAGES EOL definitions_messages END T_LC_MESSAGES newlines
 ;

definitions_messages
 : single_definition_messages
 | definitions_messages single_definition_messages
 ;

single_definition_messages
 : FIELD_MESSAGES STRING EOL ;

character_value
 : CHARACTER_NAME
 | character_literals
 ;

field_bytes_value
 : NUMBER { $$ = std::vector<int16_t>{$1}; }
 | field_bytes_value SEMICOLON NUMBER { $1.push_back($3); $$ = $1; }
 | field_bytes_value SEMICOLON ESCAPE EOL NUMBER { $1.push_back($5); $$ = $1; }
 ;

field_strings_value
 : STRING { $$ = std::vector<std::string>{$1}; }
 | field_strings_value SEMICOLON STRING { $1.push_back($3); $$ = $1; }
 | field_strings_value SEMICOLON ESCAPE EOL STRING { $1.push_back($5); $$ = $1; }
 ;

character_literals
 : CHARACTER_LITERAL { $$ = std::string{(char)$1}; }
 | character_literals CHARACTER_LITERAL { $1.push_back((char)$2); $$ = $1; }
 ;

%%

namespace locale_parser {
    parser::symbol_type locale_parserlex(){
        auto l = locale::get_lexer();
        return l->get_token();
    }

    void parser::error(const std::string& m){
        std::cerr << m << std::endl;
    }
}
